# 1. Реализовать скрипт, в котором должна быть предусмотрена функция расчета заработной платы сотрудника.
# В расчете необходимо использовать формулу: (выработка в часах * ставка в час) + премия.
# Для выполнения расчета для конкретных значений необходимо запускать скрипт с параметрами.
from sys import argv

salary = lambda p, r, b: int(p) * int(r) + int(b)
""" расчитывает заработную плату: (выроботка * ставку + премия) и выводит результат на печать """

script_name, production, rate, bonus = argv
print('Имя скрипта: ', script_name)
print('Выроботка в часах: ', production)
print('Ставка в час: ', rate)
print('Премия: ', bonus)
print(f'Зарплата = {salary(int(production), int(rate), int(bonus))}')


# 2. Представлен список чисел. Необходимо вывести элементы исходного списка,
# значения которых больше предыдущего элемента.
# Подсказка: элементы, удовлетворяющие условию, оформить в виде списка. Для формирования списка использовать генератор.

numbers = [300, 2, 12, 44, 1, 1, 4, 10, 7, 1, 78, 123, 55]  # Пример исходного списка
print(list(numbers[el] for el in range(1, len(numbers)) if numbers[el] > numbers[el-1]))  # [12, 44, 4, 10, 78, 123]


# 3. Для чисел в пределах от 20 до 240 найти числа, кратные 20 или 21. Необходимо решить задание в одну строку.
# Подсказка: использовать функцию range() и генератор.

print(list(number for number in range(20, 240) if number % 20 == 0 or number % 21 == 0))  # 240 не включительно


# 4. Представлен список чисел. Определить элементы списка, не имеющие повторений.
# Сформировать итоговый массив чисел, соответствующих требованию.
# Элементы вывести в порядке их следования в исходном списке.
# Для выполнения задания обязательно использовать генератор.

numbers_2 = [2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11]  # Пример исходного списка
print(list(number for number in numbers_2 if numbers_2.count(number) == 1))  # [23, 1, 3, 10, 4, 11]


# 5. Реализовать формирование списка, используя функцию range() и возможности генератора.
# В список должны войти четные числа от 100 до 1000 (включая границы).
# Необходимо получить результат вычисления произведения всех элементов списка.
# Подсказка: использовать функцию reduce().

import functools as ft  # импорт модуля через псевдоним (не занимает место в ОЗУ)
from random import randrange  # импорт через from (сохраняет функцию в ОЗУ на время выполнения кода)


def composition(prev_num, num):
    """ получает 2 аргумента и возвращает их произведение """
    return prev_num * num


numbers_3 = list(randrange(100, 1001, 2) for number in range(4))
print(f'Сгененрирован список 4х чётных чисел в диапазоне от 100 до 1000: {numbers_3}')
print(f'Произведение всех этих чисел = {ft.reduce(composition, numbers_3)}')


# 6. Реализовать два небольших скрипта:
# а) бесконечный итератор, генерирующий целые числа, начиная с указанного,
# б) бесконечный итератор, повторяющий элементы некоторого списка, определенного заранее.
# Подсказка: использовать функцию count() и cycle() модуля itertools.
# Обратите внимание, что создаваемый цикл не должен быть бесконечным. Необходимо предусмотреть условие его завершения.
# Например, в первом задании выводим целые числа, начиная с 3, а при достижении числа 10 завершаем цикл.
# Во втором также необходимо предусмотреть условие, при котором повторение элементов списка будет прекращено.

import itertools as it


def list_gen(n):
    """ принимает число, как аргумент и генерирует список возрастающих чисел, начиная с аргумента до бесконечности*
        *для остановки бесконечной генерации установлено условие для выхода из цикла
    """
    result = []
    for i in it.count(n):  # генерируем целые числа
        if i > 6:  # условие для остановки бесконечной генерации
            break
        else:
            result.append(i)  # добавляем новое число в список для подстановуки
            print(result)  # результат выводим на печать
            repeat_gen(result)  # результат как агрумент подставляем во вложенную функцию


def repeat_gen(m):
    """ получает список, как аргумент и выводит на печать беконечное* повторение его элементов
        *для остановки бесконечной генерации реализован счётчик выхода из цикла
    """
    count = 0
    for j in it.cycle(m):  # для каждого элемента в списке n циклично ...
        if count == 5:  # до 5 раз (счётчик остановки цикла)
            break
        print(j)  # выводим на печать каждый элемент
        count += 1


list_gen(3)
